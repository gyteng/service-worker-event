(()=>{const e={},s=async(n,a)=>{const o=await self.clients.get(n.id);if(!o)return void delete e[n.id];const i=t(n);if(a&&(a.from="service worker event",i.combineMessages.push(a)),30>Date.now()-i.lastSendMessage&&i.combineMessages.length<100)return i.sendMessageTimeout&&clearTimeout(i.sendMessageTimeout),void(i.sendMessageTimeout=self.setTimeout((()=>{i.sendMessageTimeout=null,s(n)}),Date.now()-i.lastSendMessage));i.lastSendMessage=Date.now(),o.postMessage(i.combineMessages),i.combineMessages=[]},t=s=>e[s.id],n=s=>{const t=s.source;e[t.id]={client:t,events:new Set,lastSendMessage:0,sendMessageTimeout:null,combineMessages:[]}},a=s=>{const t=s.source;delete e[t.id]};self.addEventListener("message",(o=>{const i=o.source;let d=[];Array.isArray(o.data)?d=o.data:d[0]=o.data;for(const c of d){const{from:d,type:r,eventName:l,data:m}=c;if("service worker event"!==d)return;if("unregister"===r&&a(o),"on"===r||"once"===r){e[i.id]||n(o);const{events:s}=t(i);s.add(l)}if("emit"===r)for(const t in e){const{client:n,events:a}=e[t];a.has(l)&&i.id!==n.id&&s(n,{type:r,eventName:l,data:m})}if("remove"===r){const{events:e}=t(i);e&&e.delete(l)}if("removeAll"===r)for(const t in e){const{client:n,events:a}=e[t];a.has(l)&&(s(n,{type:r,eventName:l,data:m}),a&&a.delete(l))}}}))})();